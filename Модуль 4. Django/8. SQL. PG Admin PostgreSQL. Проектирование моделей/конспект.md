# Урок 8. SQL. PG Admin PostgreSQL. Проектирование моделей

#### Введение

Проектирование баз данных — это важный этап в разработке приложений, который включает в себя сбор требований, концептуальное и логическое проектирование, физическое проектирование и реализацию. В этом материале мы рассмотрим основные этапы проектирования баз данных, нормальные формы, типы данных в PostgreSQL, а также примеры создания таблиц и использования индексов.

#### Этапы проектирования базы данных

Проектирование базы данных можно сравнить с постройкой дома. Вот основные этапы:

1. **Сбор требований**:
   - **Аналогия**: Планирование дома. Определяете, сколько комнат вам нужно, какие функции они должны выполнять (спальня, кухня, гостиная и т.д.).
   - **Описание**: Определяете, какие данные нужно хранить и как они будут использоваться.

2. **Концептуальное проектирование**:
   - **Аналогия**: Чертеж дома. Рисуете план дома, где каждая комната имеет свое место и связи между ними (например, дверь между кухней и гостиной).
   - **Описание**: Создаете ER-диаграммы (Entity-Relationship) для визуализации сущностей и их связей.

3. **Логическое проектирование**:
   - **Аналогия**: Детализация плана. Определяете, какие материалы будут использоваться для стен, пола, потолка и т.д.
   - **Описание**: Определяете таблицы, столбцы, типы данных и ограничения.

4. **Физическое проектирование**:
   - **Аналогия**: Строительство дома. Возводите стены, укладываете пол, устанавливаете двери и окна.
   - **Описание**: Оптимизация структуры базы данных для конкретной СУБД, включая индексы, партиционирование и т.д.

5. **Реализация**:
   - **Аналогия**: Заселение в дом. Переносите мебель, украшаете комнаты и начинаете жить.
   - **Описание**: Создание базы данных и таблиц в СУБД.

#### Нормальные формы

Нормальные формы помогают организовать данные в базе данных таким образом, чтобы избежать избыточности и обеспечить целостность данных. Вот подробное объяснение первых трех нормальных форм:

1. **Первая нормальная форма (1NF)**:
   - **Описание**: Каждая таблица должна иметь уникальный первичный ключ.
   - **Пример**: В таблице `orders` каждая запись должна иметь уникальный идентификатор `order_id`.

2. **Вторая нормальная форма (2NF)**:
   - **Описание**: Таблица должна быть в 1NF, и все неключевые атрибуты должны полностью зависеть от первичного ключа.
   - **Пример**: В таблице `orders` с первичным ключом `order_id` и атрибутами `customer_id`, `product_id`, `quantity`, `price`, атрибуты `customer_id` и `product_id` должны полностью зависеть от `order_id`.
   - **Отличие от 3NF**: В 2NF все неключевые атрибуты должны зависеть только от первичного ключа, но могут быть транзитивные зависимости (например, `price` может зависеть от `product_id`).

3. **Третья нормальная форма (3NF)**:
   - **Описание**: Таблица должна быть в 2NF, и все атрибуты должны зависеть только от первичного ключа (не должно быть транзитивных зависимостей).
   - **Пример**: В таблице `orders` с первичным ключом `order_id` и атрибутами `customer_id`, `product_id`, `quantity`, `price`, атрибут `price` не должен зависеть от `product_id`. Вместо этого `price` должен быть в отдельной таблице `products` с первичным ключом `product_id`.
   - **Отличие от 2NF**: В 3NF не должно быть транзитивных зависимостей. Все атрибуты должны зависеть только от первичного ключа.

#### Типы данных в PostgreSQL

PostgreSQL поддерживает широкий спектр типов данных, которые могут быть использованы для хранения различных видов информации. Вот список основных типов данных и их применения:

1. **Числовые типы**:
   - **INTEGER**: Целое число. Используется для хранения целых чисел, таких как идентификаторы, количества и т.д.
   - **BIGINT**: Большое целое число. Используется для хранения очень больших целых чисел.
   - **SMALLINT**: Малое целое число. Используется для хранения небольших целых чисел.
   - **NUMERIC (или DECIMAL)**: Число с фиксированной точностью. Используется для хранения денежных сумм, процентов и других точных чисел.
   - **REAL**: Число с плавающей точкой одинарной точности. Используется для хранения чисел с плавающей точкой, где точность не критична.
   - **DOUBLE PRECISION**: Число с плавающей точкой двойной точности. Используется для хранения чисел с плавающей точкой, где требуется высокая точность.
   - **SERIAL**: Автоинкрементное целое число. Используется для создания уникальных идентификаторов.

2. **Строковые типы**:
   - **CHAR(n)**: Фиксированная длина строки. Используется для хранения строк фиксированной длины.
   - **VARCHAR(n)**: Переменная длина строки. Используется для хранения строк переменной длины.
   - **TEXT**: Строка переменной длины без ограничения. Используется для хранения больших объемов текста.

3. **Дата и время**:
   - **DATE**: Дата. Используется для хранения дат без времени.
   - **TIME**: Время. Используется для хранения времени без даты.
   - **TIMESTAMP**: Дата и время. Используется для хранения даты и времени.
   - **TIMESTAMPTZ**: Дата и время с часовым поясом. Используется для хранения даты и времени с учетом часового пояса.
   - **INTERVAL**: Интервал времени. Используется для хранения промежутков времени.

4. **Логические типы**:
   - **BOOLEAN**: Логическое значение. Используется для хранения значений TRUE или FALSE.

5. **Двоичные типы**:
   - **BYTEA**: Двоичные данные. Используется для хранения двоичных данных, таких как изображения, файлы и т.д.

6. **Специальные типы**:
   - **UUID**: Универсальный уникальный идентификатор. Используется для хранения уникальных идентификаторов.
   - **JSON**: JSON данные. Используется для хранения данных в формате JSON.
   - **JSONB**: Двоичный JSON. Используется для хранения данных в формате JSON с более эффективным хранением и поиском.
   - **ARRAY**: Массив. Используется для хранения массивов данных.
   - **ENUM**: Перечисление. Используется для хранения значений из заранее определенного набора.

#### Индексы

Индексы — это специальные структуры данных, которые ускоряют поиск и сортировку данных в базе данных. Они работают аналогично указателю в книге, который позволяет быстро найти нужную страницу без необходимости просматривать всю книгу.

- **Аналогия**: Представьте себе библиотеку с тысячами книг. Без каталога (индекса) вам придется просматривать каждую книгу, чтобы найти нужную. Каталог (индекс) позволяет быстро найти нужную книгу по автору, названию или теме.
- **Для чего нужны**:
  - **Ускорение поиска**: Индексы значительно ускоряют выполнение запросов, особенно в больших таблицах.
  - **Оптимизация сортировки**: Индексы помогают быстро сортировать данные по определенным столбцам.
  - **Уникальность данных**: Индексы могут обеспечивать уникальность значений в столбцах, что помогает избежать дублирования данных.

#### Пример создания базы данных

Вот пример создания базы данных в PostgreSQL, соответствующей модели данных из Django ORM:

```sql
-- Создание таблицы Category
CREATE TABLE category (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор категории
    name VARCHAR(255) UNIQUE NOT NULL -- Уникальное имя категории
);

-- Создание таблицы Tag
CREATE TABLE tag (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор тега
    name VARCHAR(255) UNIQUE NOT NULL -- Уникальное имя тега
);

-- Создание таблицы Article
CREATE TABLE article (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор статьи
    title VARCHAR(255) NOT NULL, -- Заголовок статьи
    content TEXT NOT NULL, -- Содержание статьи
    publication_date TIMESTAMPTZ DEFAULT NOW(), -- Дата публикации статьи
    views INTEGER DEFAULT 0, -- Количество просмотров статьи
    category_id INTEGER NOT NULL DEFAULT 1, -- Идентификатор категории статьи
    slug VARCHAR(255) UNIQUE, -- Уникальный slug статьи
    is_active BOOLEAN DEFAULT TRUE, -- Статус активности статьи
    FOREIGN KEY (category_id) REFERENCES category(id) ON DELETE CASCADE -- Внешний ключ на таблицу Category
);

-- Создание таблицы для связи Article и Tag
CREATE TABLE article_tag (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор связи
    article_id INTEGER NOT NULL, -- Идентификатор статьи
    tag_id INTEGER NOT NULL, -- Идентификатор тега
    FOREIGN KEY (article_id) REFERENCES article(id) ON DELETE CASCADE, -- Внешний ключ на таблицу Article
    FOREIGN KEY (tag_id) REFERENCES tag(id) ON DELETE CASCADE -- Внешний ключ на таблицу Tag
);

-- Создание индексов для ускорения поиска
CREATE INDEX idx_article_title ON article (title); -- Индекс для поиска по заголовку статьи
CREATE INDEX idx_article_slug ON article (slug); -- Индекс для поиска по slug статьи

-- Создание триггера для автоматического заполнения slug
CREATE OR REPLACE FUNCTION update_slug() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.slug IS NULL THEN
        NEW.slug := slugify(NEW.title); -- Функция slugify должна быть определена заранее
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_slug
BEFORE INSERT OR UPDATE ON article
FOR EACH ROW
EXECUTE FUNCTION update_slug();
```

#### Объяснение:

- **Таблица `category`**: Хранит категории статей.
- **Таблица `tag`**: Хранит теги статей.
- **Таблица `article`**: Хранит статьи с полями для заголовка, содержания, даты публикации, количества просмотров, категории, slug и статуса активности.
- **Таблица `article_tag`**: Хранит связи между статьями и тегами (многие ко многим).
- **Индексы**: Ускоряют поиск по заголовку и slug статьи.
- **Триггер**: Автоматически заполняет поле `slug` на основе заголовка статьи, если оно не задано.

#### Заключение

Проектирование базы данных — это важный этап в разработке приложений. Следуя лучшим практикам и избегая плохих, можно создать эффективную и надежную базу данных, которая будет соответствовать требованиям вашего проекта. Индексы играют ключевую роль в оптимизации производительности базы данных, ускоряя поиск и сортировку данных.