## Урок 8

### Немного об SQL

SQL (Structured Query Language) — это стандартный язык для работы с реляционными базами данных. Он позволяет выполнять различные операции, такие как создание, изменение, удаление и извлечение данных.

#### Основные команды SQL:
- **SELECT**: Извлечение данных из базы данных.
- **INSERT**: Добавление новых данных в таблицу.
- **UPDATE**: Обновление существующих данных в таблице.
- **DELETE**: Удаление данных из таблицы.
- **CREATE**: Создание новых таблиц или баз данных.
- **ALTER**: Изменение структуры существующей таблицы.
- **DROP**: Удаление таблицы или базы данных. 

#### Примеры использования:
- **SELECT**: `SELECT * FROM users;`
- **INSERT**: `INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');`
- **UPDATE**: `UPDATE users SET email = 'newemail@example.com' WHERE name = 'John Doe';`
- **DELETE**: `DELETE FROM users WHERE name = 'John Doe';`

SQL является мощным инструментом для управления данными и используется в различных системах управления базами данных (СУБД), таких как PostgreSQL, MySQL, Oracle и другие.

**commit: `Урок 8: немного об SQL`**

### Основные возможности pgAdmin: Управление базой данных и визуализация

pgAdmin — это мощный инструмент для управления базами данных PostgreSQL, который предоставляет широкий спектр возможностей для администрирования и визуализации данных.

#### Основные возможности:
- **Управление базой данных**: Создание, изменение и удаление баз данных, таблиц, индексов, представлений и других объектов.
- **Визуализация данных**: Графическое представление структуры базы данных, визуализация запросов и результатов выполнения.
- **Мониторинг и управление производительностью**: Мониторинг и управление производительностью базы данных.
- **Управление пользователями и ролями**: Настройка прав доступа и управление пользователями.

#### Примеры использования:
- **Создание таблицы**: Используйте графический интерфейс для создания новых таблиц.
- **Выполнение запросов**: Используйте вкладку "Query Tool" для выполнения SQL-запросов.
- **Визуализация данных**: Построение диаграмм и отчетов на основе данных.

pgAdmin позволяет эффективно управлять базами данных PostgreSQL, обеспечивая удобный и интуитивно понятный интерфейс для выполнения различных задач.

**commit: `Урок 8: основные возможности pgAdmin: Управление базой данных и визуализация`**

### Создание таблиц: Структура и параметры таблиц

Создание таблиц в PostgreSQL — это процесс определения структуры данных, которые будут храниться в базе данных. Вот пошаговое руководство по созданию таблиц:

#### Шаги создания таблицы:
1. **Откройте pgAdmin и подключитесь к серверу**.
2. **Выберите базу данных**.
3. **Создайте новую таблицу**:
   - Щелкните правой кнопкой мыши на базе данных и выберите "Create" -> "Table".
   - Введите имя таблицы и выберите схему (по умолчанию `public`).
4. **Определите столбцы**:
   - В разделе "Columns" добавьте столбцы, указав их имена, типы данных и ограничения (например, NOT NULL, UNIQUE).
5. **Сохраните таблицу**:
   - Нажмите "Save" для создания таблицы.

#### Параметры таблиц:
- **Типы данных**: Определяют, какие данные могут храниться в столбцах (например, `INTEGER`, `VARCHAR`, `DATE`).
- **Ограничения**: Ограничения, такие как `NOT NULL`, `UNIQUE`, `CHECK`, которые обеспечивают целостность данных.
- **Индексы**: Структуры, которые ускоряют поиск данных.
- **Внешние ключи**: Ссылки на первичные ключи в других таблицах, которые устанавливают связи между таблицами.

#### Пример создания таблицы:
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL
);
```

**commit: `Урок 8: cоздание таблиц: Структура и параметры таблиц`**

### Типы данных: Основные типы данных PostgreSQL

PostgreSQL поддерживает широкий спектр типов данных, которые могут быть использованы для хранения различных видов информации. Вот список основных типов данных и их применения:

#### Числовые типы:
- **INTEGER**: Целое число. Используется для хранения целых чисел, таких как идентификаторы, количества и т.д.
- **BIGINT**: Большое целое число. Используется для хранения очень больших целых чисел.
- **SMALLINT**: Малое целое число. Используется для хранения небольших целых чисел.
- **NUMERIC (или DECIMAL)**: Число с фиксированной точностью. Используется для хранения денежных сумм, процентов и других точных чисел.
- **REAL**: Число с плавающей точкой одинарной точности. Используется для хранения чисел с плавающей точкой, где точность не критична.
- **DOUBLE PRECISION**: Число с плавающей точкой двойной точности. Используется для хранения чисел с плавающей точкой, где требуется высокая точность.
- **SERIAL**: Автоинкрементное целое число. Используется для создания уникальных идентификаторов.

#### Строковые типы:
- **CHAR(n)**: Фиксированная длина строки. Используется для хранения строк фиксированной длины.
- **VARCHAR(n)**: Переменная длина строки. Используется для хранения строк переменной длины.
- **TEXT**: Строка переменной длины без ограничения. Используется для хранения больших объемов текста.

#### Дата и время:
- **DATE**: Дата. Используется для хранения дат без времени.
- **TIME**: Время. Используется для хранения времени без даты.
- **TIMESTAMP**: Дата и время. Используется для хранения даты и времени.
- **TIMESTAMPTZ**: Дата и время с часовым поясом. Используется для хранения даты и времени с учетом часового пояса.
- **INTERVAL**: Интервал времени. Используется для хранения промежутков времени.

#### Логические типы:
- **BOOLEAN**: Логическое значение. Используется для хранения значений TRUE или FALSE.

#### Двоичные типы:
- **BYTEA**: Двоичные данные. Используется для хранения двоичных данных, таких как изображения, файлы и т.д.

#### Специальные типы:
- **UUID**: Универсальный уникальный идентификатор. Используется для хранения уникальных идентификаторов.
- **JSON**: JSON данные. Используется для хранения данных в формате JSON.
- **JSONB**: Двоичный JSON. Используется для хранения данных в формате JSON с более эффективным хранением и поиском.
- **ARRAY**: Массив. Используется для хранения массивов данных.
- **ENUM**: Перечисление. Используется для хранения значений из заранее определенного набора.

Понимание типов данных в PostgreSQL помогает эффективно проектировать и разрабатывать приложения, обеспечивая правильное хранение и обработку данных.

**commit: `Урок 8: типы данных: Основные типы данных PostgreSQL`**

### Проектирование моделей баз данных: Оптимизация структуры базы данных для типичных задач

Проектирование базы данных — это процесс создания структуры базы данных, которая эффективно хранит, извлекает и управляет данными. Основные шаги проектирования базы данных включают:

#### Этапы проектирования базы данных:
1. **Сбор требований**: Определение, какие данные нужно хранить и как они будут использоваться.
2. **Концептуальное проектирование**: Создание ER-диаграмм (Entity-Relationship) для визуализации сущностей и их связей.
3. **Логическое проектирование**: Определение таблиц, столбцов, типов данных и ограничений.
4. **Физическое проектирование**: Оптимизация структуры базы данных для конкретной СУБД, включая индексы, партиционирование и т.д.
5. **Реализация**: Создание базы данных и таблиц в СУБД.

#### Нормальные формы:
Нормальные формы помогают организовать данные в базе данных таким образом, чтобы избежать избыточности и обеспечить целостность данных.

1. **Первая нормальная форма (1NF)**:
   - Каждая таблица должна иметь уникальный первичный ключ.
   - Каждый столбец должен содержать атомарные значения (не должно быть массивов или списков в одном столбце).

2. **Вторая нормальная форма (2NF)**:
   - Таблица должна быть в 1NF.
   - Все неключевые атрибуты должны полностью зависеть от первичного ключа.

3. **Третья нормальная форма (3NF)**:
   - Таблица должна быть в 2NF.
   - Все атрибуты должны зависеть только от первичного ключа (не должно быть транзитивных зависимостей).

#### Индексы:
Индексы — это специальные структуры данных, которые ускоряют поиск и сортировку данных в базе данных. Они работают аналогично указателю в книге, который позволяет быстро найти нужную страницу без необходимости просматривать всю книгу.

- **Аналогия**: Представьте себе библиотеку с тысячами книг. Без каталога (индекса) вам придется просматривать каждую книгу, чтобы найти нужную. Каталог (индекс) позволяет быстро найти нужную книгу по автору, названию или теме.
- **Для чего нужны**:
  - **Ускорение поиска**: Индексы значительно ускоряют выполнение запросов, особенно в больших таблицах.
  - **Оптимизация сортировки**: Индексы помогают быстро сортировать данные по определенным столбцам.
  - **Уникальность данных**: Индексы могут обеспечивать уникальность значений в столбцах, что помогает избежать дублирования данных.

#### Пример создания базы данных:
```sql
-- Создание таблицы Category
CREATE TABLE category (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор категории
    name VARCHAR(255) UNIQUE NOT NULL -- Уникальное имя категории
);

-- Создание таблицы Tag
CREATE TABLE tag (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор тега
    name VARCHAR(255) UNIQUE NOT NULL -- Уникальное имя тега
);

-- Создание таблицы Article
CREATE TABLE article (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор статьи
    title VARCHAR(255) NOT NULL, -- Заголовок статьи
    content TEXT NOT NULL, -- Содержание статьи
    publication_date TIMESTAMPTZ DEFAULT NOW(), -- Дата публикации статьи
    views INTEGER DEFAULT 0, -- Количество просмотров статьи
    category_id INTEGER NOT NULL DEFAULT 1, -- Идентификатор категории статьи
    slug VARCHAR(255) UNIQUE, -- Уникальный slug статьи
    is_active BOOLEAN DEFAULT TRUE, -- Статус активности статьи
    FOREIGN KEY (category_id) REFERENCES category(id) ON DELETE CASCADE -- Внешний ключ на таблицу Category
);

-- Создание таблицы для связи Article и Tag
CREATE TABLE article_tag (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор связи
    article_id INTEGER NOT NULL, -- Идентификатор статьи
    tag_id INTEGER NOT NULL, -- Идентификатор тега
    FOREIGN KEY (article_id) REFERENCES article(id) ON DELETE CASCADE, -- Внешний ключ на таблицу Article
    FOREIGN KEY (tag_id) REFERENCES tag(id) ON DELETE CASCADE -- Внешний ключ на таблицу Tag
);

-- Создание индексов для ускорения поиска
CREATE INDEX idx_article_title ON article (title); -- Индекс для поиска по заголовку статьи
CREATE INDEX idx_article_slug ON article (slug); -- Индекс для поиска по slug статьи

-- Создание триггера для автоматического заполнения slug
CREATE OR REPLACE FUNCTION update_slug() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.slug IS NULL THEN
        NEW.slug := slugify(NEW.title); -- Функция slugify должна быть определена заранее
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_slug
BEFORE INSERT OR UPDATE ON article
FOR EACH ROW
EXECUTE FUNCTION update_slug();
```

**commit: `Урок 8: проектирование моделей баз данных: Оптимизация структуры базы данных для типичных задач`**
